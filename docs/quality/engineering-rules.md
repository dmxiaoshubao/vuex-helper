# 工程协作规则（默认执行）

> 目的：沉淀本项目在规范、性能、缓存、复用、测试上的约束。  
> 约定：后续接到需求时，默认先按本文件执行，不需要重复提醒。

## 1. 执行优先级

1. 正确性优先：先保证功能语义正确，再做性能与体验优化。
2. 性能优先于“花哨实现”：热路径避免不必要解析、遍历、对象创建。
3. 复用优先：Provider 之间重复逻辑必须抽公共工具/服务，避免三处漂移。
4. 可回归优先：每次修复需配套单测；涉及宿主行为的改动需补 host 用例。

## 2. 代码规范

1. 小步修改，避免一次性大改多模块。
2. 仅在复杂逻辑前写简短注释，避免无信息量注释。
3. 不做破坏性 git 操作（如 `reset --hard`）除非明确要求。
4. 变更应尽量局部化，避免无关格式化噪音。

## 3. 性能规则（必须遵守）

1. Provider 热路径（completion/definition/hover）禁止重复扫描同一上下文。
2. 正则匹配要“收紧”，避免宽匹配导致误判和额外 lookup。
3. 优先使用窗口化文本读取与轻量解析，不做整文件重型处理。
4. 可选链场景与普通场景要统一处理，避免分支遗漏导致回退重试。
5. 变更后必须对照性能基线：`docs/quality/performance-baseline.md`。

## 4. 缓存规则（必须遵守）

1. 增量索引不得清空全量缓存（避免抖动和重复构建）。
2. `ComponentMapper` 等文档级缓存需保持有界（LRU 上限）并可 `dispose` 清理。
3. 语义签名未变时优先复用缓存，避免编辑过程中的重复 AST 解析。
4. 缓存 key 与作用域要稳定（`uri/filePath + namespace`），避免串读。
5. 新增缓存必须提供：
   - 失效条件
   - 上限策略
   - 清理时机
   - 对应单测

## 5. 可复用规则

1. Provider 公共逻辑统一放到 `src/utils/VuexProviderUtils.ts`。
2. Store 查询统一走 `src/services/VuexLookupService.ts`，避免各 Provider 自行拼装查找。
3. 同一语义（如 bracket/dot/optional-chain 路径提取）只保留一份实现。

## 6. 测试规则（必须遵守）

1. 行为修复必须先补回归测试再提交，至少覆盖：
   - 正向命中
   - 负向防误判
   - 可选链/编辑中不完整语法
2. 影响 Provider 的改动至少跑：
   - `npm run test:unit`
   - 相关 target 测试（如 `DefinitionProvider.test` / `HoverProvider.test`）
3. 影响宿主行为或语言扩展依赖时跑：
   - `npm run test:host`（隔离）
   - `npm run test:host:vue`（Vue 语言扩展）

## 7. Host 测试规则

1. `test:host`：纯隔离模式，不加载本机扩展。
2. `test:host:vue`：仅加载一个 Vue 语言扩展 + 当前开发扩展。
3. 扩展选择优先级：`vue.volar` -> `octref.vetur`（自动回退）。
4. 可通过环境变量固定来源（版本或目录），保证复现性。

## 8. 提交流程（默认）

1. 先跑：`compile` -> 相关单测 -> `test:unit`（必要时 host）。
2. 再检查：是否引入性能回退、缓存失效、误判分支。
3. 最后提交：提交信息需体现“行为变化 + 目标”。

## 9. 需求响应默认流程

1. 先读本文件与性能基线文档。
2. 给出最小可行修复方案（含风险点）。
3. 实施代码改动并补回归测试。
4. 跑验证并报告结果（通过项、未跑项、残余风险）。

